#version 430

layout(local_size_x = COMPUTE_SIZE_X, local_size_y = COMPUTE_SIZE_Y) in;

struct Agent{
    vec2 c;
    vec2 v;
    float w_g;
    float w_s;
    float theta;
    float grad_travel;
};

// Grid cell structure
struct GridCell {
    uint start_index;
    uint count;
    uint padding[2];   // Align to 16 bytes
};

// Agent with grid key for sorting
struct AgentGridKey {
    uint agent_index;
    uint grid_key;
    uint padding[2];   // Align to 16 bytes
};

// Input agents
layout(std430, binding = 0) readonly buffer agents_in {
    Agent agents[];
} In;

// Parameters
layout(std430, binding = 2) readonly buffer parm_in {
    float r_a;
    float r_s;
    float s;
    float l;
    float t;
    float sigma_g;
    float sigma_r;
    float theta_max;
    float dt;
    float world_size;
    float tp;
    uint grid_size;
    float cell_size;
} Par;

// Output: Agent indices with grid keys (to be sorted externally)
layout(std430, binding = 6) writeonly buffer agent_keys_out {
    AgentGridKey agent_keys[];
} AgentKeys;

// Output: Grid cells (will be filled after sorting)
layout(std430, binding = 1) writeonly buffer grid_out {
    GridCell grid[];
} GridOut;

// Get grid cell coordinates from world position
ivec2 get_grid_coords(vec2 pos, float world_size, uint grid_size) {
    // Normalize position to [0, 1)
    vec2 normalized = pos / world_size;
    
    // Handle edge case where pos might be exactly world_size
    normalized = mod(normalized + 1.0, 1.0);
    
    // Convert to grid coordinates
    ivec2 coords = ivec2(floor(normalized * float(grid_size)));
    
    // Clamp to valid range
    coords = clamp(coords, ivec2(0), ivec2(int(grid_size) - 1));
    
    return coords;
}

// Convert 2D grid coordinates to linear key
uint grid_coords_to_key(ivec2 coords, uint grid_size) {
    return uint(coords.y * int(grid_size) + coords.x);
}

void main() {
    uint agent_id = gl_GlobalInvocationID.x;
    uint num_agents = In.agents.length();
    
    // Check bounds
    if (agent_id >= num_agents) {
        return;
    }
    
    // Get agent position
    vec2 agent_pos = In.agents[agent_id].c;
    
    // Calculate grid cell
    ivec2 grid_coords = get_grid_coords(agent_pos, Par.world_size, Par.grid_size);
    uint grid_key = grid_coords_to_key(grid_coords, Par.grid_size);
    
    // Store agent index and grid key for sorting
    AgentKeys.agent_keys[agent_id].agent_index = agent_id;
    AgentKeys.agent_keys[agent_id].grid_key = grid_key;
    
    // Initialize grid cells (will be properly filled after sorting)
    if (agent_id < Par.grid_size * Par.grid_size) {
        GridOut.grid[agent_id].start_index = 0;
        GridOut.grid[agent_id].count = 0;
    }
}