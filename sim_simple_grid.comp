#version 430

layout(local_size_x = COMPUTE_SIZE_X, local_size_y = COMPUTE_SIZE_Y) in;

struct Agent{
    vec2 c;
    vec2 v;
    float w_g;
    float w_s;
    float theta;
    float grad_travel;
};

// Grid cell structure for spatial partitioning
struct GridCell {
    uint start_index;  // First agent in this cell
    uint count;        // Number of agents in this cell
    uint padding[2];   // Align to 16 bytes
};

// Input agents
layout(std430, binding = 0) readonly buffer pairs_in {
    Agent agents[];
} In;

// Spatial grid for O(N) neighbor finding
layout(std430, binding = 1) readonly buffer grid_buffer {
    GridCell grid[];
} Grid;

// Sorted agent indices for spatial coherence
layout(std430, binding = 3) readonly buffer sorted_indices_buffer {
    uint sorted_indices[];
} SortedIndices;

// Simulation parameters
layout(std430, binding = 2) readonly buffer parm_in {
    float r_a;      // Zone of avoidance radius
    float r_s;      // Zone of socialization radius  
    float s;        // Speed (constant)
    float l;        // System size
    float t;        // Current time
    float sigma_g;  // Gradient detection noise
    float sigma_r;  // Random motion noise
    float theta_max; // Maximum turning rate
    float dt;       // Time step
    float world_size; // World boundary size
    float tp;       // Time period for boundary perturbation
    uint grid_size; // Grid dimensions (grid_size x grid_size)
    float cell_size; // Size of each grid cell
} Par;

// Output agents
layout(std430, binding = 5) writeonly buffer vecs_out {
    Agent agents[];
} Out;

// Calculate wrapped distance for periodic boundaries (branchless)
vec2 calc_wrapped_diff(vec2 pos1, vec2 pos2, float world_size) {
    vec2 diff = pos2 - pos1;
    
    // Branchless periodic wrapping using floor function
    diff = diff - world_size * floor(diff / world_size + 0.5);
    
    return diff;
}

// Get grid cell coordinates from world position
ivec2 get_grid_coords(vec2 pos, float world_size, uint grid_size) {
    // Normalize position to [0, 1)
    vec2 normalized = pos / world_size;
    
    // Handle edge case where pos might be exactly world_size
    normalized = mod(normalized + 1.0, 1.0);
    
    // Convert to grid coordinates
    ivec2 coords = ivec2(floor(normalized * float(grid_size)));
    
    // Clamp to valid range (should not be necessary with proper modulo, but safety first)
    coords = clamp(coords, ivec2(0), ivec2(int(grid_size) - 1));
    
    return coords;
}

// Convert 2D grid coordinates to linear index
uint grid_coords_to_index(ivec2 coords, uint grid_size) {
    return uint(coords.y * int(grid_size) + coords.x);
}

// Get neighboring cells (including wrapping for periodic boundaries)
void get_neighbor_cells(ivec2 center_coords, uint grid_size, out ivec2 neighbor_coords[9]) {
    int g_size = int(grid_size);
    
    // Generate 3x3 neighborhood around center cell
    int idx = 0;
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            ivec2 coords = center_coords + ivec2(dx, dy);
            
            // Handle periodic boundaries
            coords.x = (coords.x + g_size) % g_size;
            coords.y = (coords.y + g_size) % g_size;
            
            neighbor_coords[idx] = coords;
            idx++;
        }
    }
}

// Better random number generator with hash function
uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

float random(uint seed) {
    uint hashed = hash(seed);
    return float(hashed) / 4294967295.0;  // Normalize to [0,1)
}

void main() {
    uint agent_id = gl_GlobalInvocationID.x;
    uint num_agents = In.agents.length();
    
    // Check bounds
    if (agent_id >= num_agents) {
        return;
    }
    
    // Get current agent
    Agent current_agent = In.agents[agent_id];
    vec2 agent_pos = current_agent.c;
    
    // Initialize output agent (copy current state)
    Agent new_agent = current_agent;
    
    // Social interaction vectors
    vec2 avoidance_direction = vec2(0.0, 0.0);
    vec2 social_attraction = vec2(0.0, 0.0);
    vec2 social_alignment = vec2(0.0, 0.0);
    bool has_avoidance = false;
    int social_neighbors = 0;
    
    // Precompute distance thresholds
    float r_a_squared = Par.r_a * Par.r_a;
    float r_s_squared = Par.r_s * Par.r_s;
    
    // Get current agent's grid cell
    ivec2 agent_grid_coords = get_grid_coords(agent_pos, Par.world_size, Par.grid_size);
    
    // Get neighboring cells (3x3 around current cell)
    ivec2 neighbor_coords[9];
    get_neighbor_cells(agent_grid_coords, Par.grid_size, neighbor_coords);
    
    // ========== GRID-BASED NEIGHBOR SEARCH (O(N) complexity) ==========
    // Only check agents in neighboring grid cells instead of all agents
    for (int cell_idx = 0; cell_idx < 9; cell_idx++) {
        ivec2 coords = neighbor_coords[cell_idx];
        uint cell_linear_idx = grid_coords_to_index(coords, Par.grid_size);
        
        // Get cell information
        GridCell cell = Grid.grid[cell_linear_idx];
        
        // Iterate through agents in this cell
        for (uint i = 0; i < cell.count; i++) {
            uint sorted_idx = cell.start_index + i;
            
            // Bounds check for safety
            if (sorted_idx >= SortedIndices.sorted_indices.length()) {
                continue;
            }
            
            uint other_id = SortedIndices.sorted_indices[sorted_idx];
            
            // Skip self
            if (other_id == agent_id) {
                continue;
            }
            
            // Bounds check for agent array
            if (other_id >= num_agents) {
                continue;
            }
            
            // Get neighbor agent
            Agent neighbor_agent = In.agents[other_id];
            vec2 neighbor_pos = neighbor_agent.c;
            
            // Calculate wrapped distance
            vec2 diff = calc_wrapped_diff(agent_pos, neighbor_pos, Par.world_size);
            float dist_squared = dot(diff, diff);
            
            // Skip if too far for any interaction
            if (dist_squared > r_s_squared) {
                continue;
            }
            
            float dist = sqrt(dist_squared);
            
            // Check for avoidance (highest priority) - Equation 1
            if (dist_squared <= r_a_squared && dist > 0.001) {
                has_avoidance = true;
                // AVOIDANCE: Paper Eq 1: -Σ (cj - ci) / |cj - ci|
                avoidance_direction += -diff / dist;
            }
            // Check for social interaction (only if no avoidance) - Equation 2
            else if (dist_squared <= r_s_squared && dist > 0.001) {
                social_neighbors++;
                
                // SOCIAL ATTRACTION: Paper Eq 2: Σ (cj - ci) / |cj - ci|
                social_attraction += diff / dist;
                
                // SOCIAL ALIGNMENT: Paper Eq 2: Σ vj / |vj|
                if (length(neighbor_agent.v) > 0.001) {
                    social_alignment += normalize(neighbor_agent.v);
                }
            }
        }
    }
    
    // ========== COMPUTE DESIRED DIRECTION ==========
    // [Rest of the computation remains exactly the same as original shader]
    vec2 desired_direction = vec2(0.0, 0.0);
    
    if (has_avoidance) {
        // AVOIDANCE has highest priority
        if (length(avoidance_direction) > 0.0) {
            desired_direction = normalize(avoidance_direction);
        } else {
            desired_direction = vec2(1.0, 0.0); // Default direction
        }
    } else {
        // Combine social and gradient forces
        
        // SOCIAL DIRECTION: Paper Eq 2: dsi = attraction + alignment  
        vec2 social_direction = social_attraction + social_alignment;
        
        // GRADIENT DIRECTION: Paper's discrete-time stochastic process (Eq. line 50)
        // θ(t + Δt) = θ(t)e^(-ωg*Δt) + √(σg²/(2ωg) * (1 - e^(-2ωg*Δt))) * ζt
        // where θ is angular deviation from migratory direction (+x axis)
        vec2 gradient_direction = vec2(0.0, 0.0);
        float w_g = new_agent.w_g;
        if (w_g > 0.001) {
            // Ornstein-Uhlenbeck process parameters
            float decay_factor = exp(-w_g * Par.dt);
            float noise_variance = Par.sigma_g * Par.sigma_g * (1.0 - exp(-2.0 * w_g * Par.dt)) / (2.0 * w_g);
            float noise_scale = sqrt(noise_variance);
            
            // Generate Gaussian white noise using Box-Muller transform
            // Use different seeds to ensure independent random numbers each timestep
            uint time_seed = uint(Par.t / Par.dt);  // Discrete timestep counter
            float u1 = random(agent_id * 1000u + time_seed * 73u + 123u);
            float u2 = random(agent_id * 1000u + time_seed * 97u + 456u);
            
            // Ensure u1 is not zero to avoid log(0)
            u1 = max(u1, 1e-8);
            
            // Box-Muller transform for Gaussian noise
            float zeta = sqrt(-2.0 * log(u1)) * cos(2.0 * 3.14159265359 * u2);
            
            // Update theta according to the Ornstein-Uhlenbeck process
            float theta = current_agent.theta * decay_factor + noise_scale * zeta;
            
            // Wrap theta to [-π, π] to avoid numerical issues
            theta = mod(theta + 3.14159265359, 2.0 * 3.14159265359) - 3.14159265359;
            
            // Store updated theta
            new_agent.theta = theta;
            
            // Convert theta to gradient direction vector
            // θ=0 means perfect +x direction, θ=±π/2 means ±y direction
            gradient_direction = vec2(cos(theta), sin(theta));
        } else {
            // No gradient detection - keep theta as is
            new_agent.theta = current_agent.theta;
        }
        
        // RANDOM DIRECTION for noise
        uint time_seed = uint(Par.t / Par.dt);  // Same time seed as gradient calculation
        float rand_x = (random(agent_id * 13u + time_seed * 37u + 2u) - 0.5) * 2.0;
        float rand_y = (random(agent_id * 19u + time_seed * 41u + 3u) - 0.5) * 2.0;
        vec2 random_direction = vec2(rand_x, rand_y);
        
        // Paper Eq 3: d'i = (ωsi*dsi + ωgi*dgi + σr*dri) / |ωsi*dsi + ωgi*dgi + σr*dri|
        desired_direction = new_agent.w_s * social_direction + 
                           new_agent.w_g * gradient_direction + 
                           Par.sigma_r * random_direction;
    }
    
    // Normalize desired direction
    if (length(desired_direction) > 0.0) {
        desired_direction = normalize(desired_direction);
    } else {
        desired_direction = vec2(0.0, 0.0); // Default to x-direction
    }
    
    // ========== APPLY MOVEMENT CONSTRAINTS ==========
    // Current velocity direction
    vec2 current_vel_dir = length(current_agent.v) > 0.001 ? 
                          normalize(current_agent.v) : vec2(1.0, 0.0);
    
    // Simple turning rate limit: blend between current and desired direction
    float turn_rate = Par.theta_max * Par.dt;
    vec2 new_direction = mix(current_vel_dir, desired_direction, turn_rate);
    
    // Set velocity with constant speed
    new_agent.v = normalize(new_direction) * Par.s;
    
    // Update position: ci(t + Δt) = ci(t) + vi(t + Δt) * Δt
    new_agent.c = current_agent.c + new_agent.v * Par.dt;
    
    // Track gradient travel (distance traveled in positive x-direction)
    float x_component = new_agent.v.x * Par.dt;
    new_agent.grad_travel = current_agent.grad_travel + x_component;
    
    // ========== PERIODIC BOUNDARY CONDITIONS ==========
    // Handle X-axis periodic boundary with perturbation
    if (new_agent.c.x >= Par.world_size) {
        new_agent.c.x -= Par.world_size;
        // No boundary perturbation for now
        // float perturbation = 10.0 * Par.s * cos(2.0 * 3.14159265359 * Par.t / Par.tp);
        // new_agent.c.y += perturbation * Par.dt;
    } else if (new_agent.c.x < 0.0) {
        new_agent.c.x += Par.world_size;
    }
    
    // Handle Y-axis periodic boundary
    if (new_agent.c.y >= Par.world_size) {
        new_agent.c.y -= Par.world_size;
    } else if (new_agent.c.y < 0.0) {
        new_agent.c.y += Par.world_size;
    }
    
    // Write updated agent to output
    Out.agents[agent_id] = new_agent;
}