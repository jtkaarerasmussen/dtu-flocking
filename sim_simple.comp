#version 430

layout(local_size_x = COMPUTE_SIZE_X, local_size_y = COMPUTE_SIZE_Y) in;

struct Agent{
    vec2 c;
    vec2 v;
    float w_g;
    float w_s;
    float theta;
    float grad_travel;
};

// Input agents
layout(std430, binding = 0) readonly buffer pairs_in {
    Agent agents[];
} In;

// Simulation parameters
layout(std430, binding = 2) readonly buffer parm_in {
    float r_a;      // Zone of avoidance radius
    float r_s;      // Zone of socialization radius  
    float s;        // Speed (constant)
    float l;        // System size
    float t;        // Current time
    float sigma_g;  // Gradient detection noise
    float sigma_r;  // Random motion noise
    float theta_max; // Maximum turning rate
    float dt;       // Time step
    float world_size; // World boundary size
    float tp;       // Time period for boundary perturbation
} Par;

// Output agents
layout(std430, binding = 5) writeonly buffer vecs_out {
    Agent agents[];
} Out;

// Calculate wrapped distance for periodic boundaries (branchless)
vec2 calc_wrapped_diff(vec2 pos1, vec2 pos2, float world_size) {
    vec2 diff = pos2 - pos1;
    
    // Branchless periodic wrapping using floor function
    diff = diff - world_size * floor(diff / world_size + 0.5);
    
    return diff;
}

// Better random number generator with hash function
uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

float random(uint seed) {
    uint hashed = hash(seed);
    return float(hashed) / 4294967295.0;  // Normalize to [0,1)
}

void main() {
    uint agent_id = gl_GlobalInvocationID.x;
    uint num_agents = In.agents.length();
    
    // Check bounds
    if (agent_id >= num_agents) {
        return;
    }
    
    // Get current agent
    Agent current_agent = In.agents[agent_id];
    vec2 agent_pos = current_agent.c;
    
    // Initialize output agent (copy current state)
    Agent new_agent = current_agent;
    
    // Social interaction vectors
    vec2 avoidance_direction = vec2(0.0, 0.0);
    vec2 social_attraction = vec2(0.0, 0.0);
    vec2 social_alignment = vec2(0.0, 0.0);
    bool has_avoidance = false;
    int social_neighbors = 0;
    
    // Precompute distance thresholds
    float r_a_squared = Par.r_a * Par.r_a;
    float r_s_squared = Par.r_s * Par.r_s;
    
    // ========== SINGLE PASS THROUGH ALL OTHER AGENTS ==========
    for (uint other_id = 0u; other_id < num_agents; other_id++) {
        // Skip self
        if (other_id == agent_id) {
            continue;
        }
        
        // Get neighbor agent
        Agent neighbor_agent = In.agents[other_id];
        vec2 neighbor_pos = neighbor_agent.c;
        
        // Calculate wrapped distance
        vec2 diff = calc_wrapped_diff(agent_pos, neighbor_pos, Par.world_size);
        float dist_squared = dot(diff, diff);
        
        // Skip if too far for any interaction
        if (dist_squared > r_s_squared) {
            continue;
        }
        
        float dist = sqrt(dist_squared);
        
        // Check for avoidance (highest priority) - Equation 1
        if (dist_squared <= r_a_squared && dist > 0.001) {
            has_avoidance = true;
            // AVOIDANCE: Paper Eq 1: -Σ (cj - ci) / |cj - ci|
            avoidance_direction += -diff / dist;
        }
        // Check for social interaction (only if no avoidance) - Equation 2
        else if (dist_squared <= r_s_squared && dist > 0.001) {
            social_neighbors++;
            
            // SOCIAL ATTRACTION: Paper Eq 2: Σ (cj - ci) / |cj - ci|
            social_attraction += diff / dist;
            
            // SOCIAL ALIGNMENT: Paper Eq 2: Σ vj / |vj|
            if (length(neighbor_agent.v) > 0.001) {
                social_alignment += normalize(neighbor_agent.v);
            }
        }
    }
    
    // ========== COMPUTE DESIRED DIRECTION ==========
    vec2 desired_direction = vec2(0.0, 0.0);
    
    if (has_avoidance) {
        // AVOIDANCE has highest priority
        if (length(avoidance_direction) > 0.0) {
            desired_direction = normalize(avoidance_direction);
        } else {
            desired_direction = vec2(1.0, 0.0); // Default direction
        }
    } else {
        // Combine social and gradient forces
        
        // SOCIAL DIRECTION: Paper Eq 2: dsi = attraction + alignment  
        vec2 social_direction = social_attraction + social_alignment;
        
        // GRADIENT DIRECTION: Paper's discrete-time stochastic process (Eq. line 50)
        // θ(t + Δt) = θ(t)e^(-ωg*Δt) + √(σg²/(2ωg) * (1 - e^(-2ωg*Δt))) * ζt
        // where θ is angular deviation from migratory direction (+x axis)
        vec2 gradient_direction = vec2(0.0, 0.0);
        float w_g = new_agent.w_g;
        if (w_g > 0.001) {
            // Ornstein-Uhlenbeck process parameters
            float decay_factor = exp(-w_g * Par.dt);
            float noise_variance = Par.sigma_g * Par.sigma_g * (1.0 - exp(-2.0 * w_g * Par.dt)) / (2.0 * w_g);
            float noise_scale = sqrt(noise_variance);
            
            // Generate Gaussian white noise using Box-Muller transform
            // Use different seeds to ensure independent random numbers each timestep
            uint time_seed = uint(Par.t / Par.dt);  // Discrete timestep counter
            float u1 = random(agent_id * 1000u + time_seed * 73u + 123u);
            float u2 = random(agent_id * 1000u + time_seed * 97u + 456u);
            
            // Ensure u1 is not zero to avoid log(0)
            u1 = max(u1, 1e-8);
            
            // Box-Muller transform for Gaussian noise
            float zeta = sqrt(-2.0 * log(u1)) * cos(2.0 * 3.14159265359 * u2);
            
            // Update theta according to the Ornstein-Uhlenbeck process
            float theta = current_agent.theta * decay_factor + noise_scale * zeta;
            
            // Wrap theta to [-π, π] to avoid numerical issues
            theta = mod(theta + 3.14159265359, 2.0 * 3.14159265359) - 3.14159265359;
            
            // Store updated theta
            new_agent.theta = theta;
            
            // Convert theta to gradient direction vector
            // θ=0 means perfect +x direction, θ=±π/2 means ±y direction
            gradient_direction = vec2(cos(theta), sin(theta));
        } else {
            // No gradient detection - keep theta as is
            new_agent.theta = current_agent.theta;
        }
        
        // RANDOM DIRECTION for noise
        uint time_seed = uint(Par.t / Par.dt);  // Same time seed as gradient calculation
        float rand_x = (random(agent_id * 13u + time_seed * 37u + 2u) - 0.5) * 2.0;
        float rand_y = (random(agent_id * 19u + time_seed * 41u + 3u) - 0.5) * 2.0;
        vec2 random_direction = vec2(rand_x, rand_y);
        
        // Paper Eq 3: d'i = (ωsi*dsi + ωgi*dgi + σr*dri) / |ωsi*dsi + ωgi*dgi + σr*dri|
        desired_direction = new_agent.w_s * social_direction + 
                           new_agent.w_g * gradient_direction + 
                           Par.sigma_r * random_direction;
    }
    
    // Normalize desired direction
    if (length(desired_direction) > 0.0) {
        desired_direction = normalize(desired_direction);
    } else {
        desired_direction = vec2(0.0, 0.0); // Default to x-direction
    }
    
    // ========== APPLY MOVEMENT CONSTRAINTS ==========
    // Current velocity direction
    vec2 current_vel_dir = length(current_agent.v) > 0.001 ? 
                          normalize(current_agent.v) : vec2(1.0, 0.0);
    
    // Simple turning rate limit: blend between current and desired direction
    float turn_rate = Par.theta_max * Par.dt;
    vec2 new_direction = mix(current_vel_dir, desired_direction, turn_rate);
    
    // Set velocity with constant speed
    new_agent.v = normalize(new_direction) * Par.s;
    
    // Update position: ci(t + Δt) = ci(t) + vi(t + Δt) * Δt
    new_agent.c = current_agent.c + new_agent.v * Par.dt;
    
    // Track gradient travel (distance traveled in positive x-direction)
    float x_component = new_agent.v.x * Par.dt;
    new_agent.grad_travel = current_agent.grad_travel + x_component;
    
    // ========== PERIODIC BOUNDARY CONDITIONS ==========
    // Handle X-axis periodic boundary with perturbation
    if (new_agent.c.x >= Par.world_size) {
        new_agent.c.x -= Par.world_size;
        // No boundary perturbation for now
        // float perturbation = 10.0 * Par.s * cos(2.0 * 3.14159265359 * Par.t / Par.tp);
        // new_agent.c.y += perturbation * Par.dt;
    } else if (new_agent.c.x < 0.0) {
        new_agent.c.x += Par.world_size;
    }
    
    // Handle Y-axis periodic boundary
    if (new_agent.c.y >= Par.world_size) {
        new_agent.c.y -= Par.world_size;
    } else if (new_agent.c.y < 0.0) {
        new_agent.c.y += Par.world_size;
    }
    
    // Write updated agent to output
    Out.agents[agent_id] = new_agent;
}