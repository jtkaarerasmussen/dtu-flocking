#version 430

// Use larger work group for shared memory efficiency
layout(local_size_x = 64, local_size_y = 1) in;

struct Agent{
    vec2 c;
    vec2 v;
    float w_g;
    float w_s;
    float theta;
    float grad_travel;
};

layout(std430, binding = 0) readonly buffer pairs_in {
    Agent agents[];
} In;

layout(std430, binding = 2) readonly buffer parm_in {
    float r_a;
    float r_s;
    float s;
    float l;
    float t;
    float sigma_g;
    float sigma_r;
    float theta_max;
    float dt;
    float world_size;
    float tp;
    uint grid_size;
    float cell_size;
} Par;

layout(std430, binding = 5) writeonly buffer vecs_out {
    Agent agents[];
} Out;

// Shared memory for neighbor positions - dramatically reduces memory reads
shared vec2 shared_positions[64];
shared vec2 shared_velocities[64];

// Calculate wrapped distance for periodic boundaries
vec2 calc_wrapped_diff(vec2 pos1, vec2 pos2, float world_size) {
    vec2 diff = pos2 - pos1;
    diff = diff - world_size * floor(diff / world_size + 0.5);
    return diff;
}

void main() {
    uint agent_id = gl_GlobalInvocationID.x;
    uint num_agents = In.agents.length();
    uint local_id = gl_LocalInvocationID.x;
    uint work_group_size = gl_WorkGroupSize.x;
    
    if (agent_id >= num_agents) {
        return;
    }
    
    Agent current_agent = In.agents[agent_id];
    vec2 agent_pos = current_agent.c;
    
    // Social force accumulators
    vec2 avoidance_force = vec2(0.0);
    vec2 social_force = vec2(0.0);
    float total_interactions = 0.0;
    
    float r_a_squared = Par.r_a * Par.r_a;
    float r_s_squared = Par.r_s * Par.r_s;
    
    // Process agents in chunks using shared memory
    for (uint chunk_start = 0; chunk_start < num_agents; chunk_start += work_group_size) {
        uint neighbor_id = chunk_start + local_id;
        
        // Load chunk of neighbor data into shared memory (coalesced reads)
        if (neighbor_id < num_agents) {
            shared_positions[local_id] = In.agents[neighbor_id].c;
            shared_velocities[local_id] = In.agents[neighbor_id].v;
        } else {
            shared_positions[local_id] = vec2(1e9, 1e9); // Far away
            shared_velocities[local_id] = vec2(0.0);
        }
        
        // Wait for all threads to finish loading
        barrier();
        
        // Process this chunk of neighbors from shared memory (fast access)
        for (uint i = 0; i < work_group_size; i++) {
            uint other_id = chunk_start + i;
            if (other_id >= num_agents || other_id == agent_id) continue;
            
            vec2 neighbor_pos = shared_positions[i];
            vec2 neighbor_vel = shared_velocities[i];
            
            vec2 diff = calc_wrapped_diff(agent_pos, neighbor_pos, Par.world_size);
            float dist_squared = dot(diff, diff);
            
            if (dist_squared > r_s_squared || dist_squared < 1e-6) continue;
            
            float dist = sqrt(dist_squared);
            vec2 unit_diff = diff / dist;
            
            // Avoidance
            if (dist_squared <= r_a_squared) {
                avoidance_force += -unit_diff;
                total_interactions += 1.0;
            }
            // Social interaction
            else if (dist_squared <= r_s_squared) {
                social_force += unit_diff; // Attraction
                if (length(neighbor_vel) > 1e-3) {
                    social_force += normalize(neighbor_vel); // Alignment
                }
                total_interactions += 0.5;
            }
        }
        
        // Wait for all threads to finish processing before loading next chunk
        barrier();
    }
    
    // Normalize forces
    avoidance_force = avoidance_force / max(total_interactions, 1e-6);
    social_force = social_force / max(total_interactions, 1e-6);
    
    // Determine behavior
    vec2 desired_direction;
    bool has_avoidance = length(avoidance_force) > 0.1;
    
    if (has_avoidance) {
        desired_direction = normalize(avoidance_force);
    } else {
        // Combine social and other forces
        vec2 combined = current_agent.w_s * social_force;
        
        // Add small random component
        combined += vec2(sin(float(agent_id) * 0.1 + Par.t), cos(float(agent_id) * 0.2 + Par.t)) * Par.sigma_r * 0.1;
        
        desired_direction = normalize(combined + vec2(1e-6, 0.0));
    }
    
    // Apply turning rate limit
    vec2 current_vel_dir = normalize(current_agent.v + vec2(1e-6, 0.0));
    float turn_rate = Par.theta_max * Par.dt;
    vec2 new_direction = mix(current_vel_dir, desired_direction, turn_rate);
    
    // Update agent
    Agent new_agent = current_agent;
    new_agent.v = normalize(new_direction) * Par.s;
    new_agent.c = current_agent.c + new_agent.v * Par.dt;
    new_agent.grad_travel = current_agent.grad_travel + new_agent.v.x * Par.dt;
    
    // Periodic boundaries
    new_agent.c.x = mod(new_agent.c.x + Par.world_size, Par.world_size);
    new_agent.c.y = mod(new_agent.c.y + Par.world_size, Par.world_size);
    
    Out.agents[agent_id] = new_agent;
}